[
    {
        "filename": "排序_PPT_第10页.png",
        "context": "不同的具体实现方法导致不同的算法描述\n最简单的排序法！\n直接插入排序（基于顺序查找）\n折半插入排序（基于折半查找）\n希尔排序（基于逐趟缩小增量）",
        "source": "排序_PPT_第10页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第11页.png",
        "context": "直接插入排序\n排序过程：整个排序过程为n-1趟插入，即先将序列中第1个记录看成是一个有序子序列，然后从第2个记录开始，逐个进行插入，直至整个序列有序。\n例（13，6，3，31，9，27，5，11）\n【13】，6，3，31，9，27，5，11\n【6，13】，3，31，9，27，5，11\n【3，6，13】，31，9，27，5，11\n【3，6，13，31】，9，27，5，11\n【3，6，9，13，31】，27，5，11\n【3，6，9，13，27，31】，5，11\n【3，5，6，9，13，27，31】，11\n【3，5，6，9，11，13，27，31】",
        "source": "排序_PPT_第11页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第12页.png",
        "context": "希尔排序\n算法思想的出发点：\n直接插入排序在基本有序时，效率较高\n在待排序的记录个数较少时，效率较高\n基本思想：\n先将整个待排记录序列分割成若干子序列，分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。",
        "source": "排序_PPT_第12页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第13页.png",
        "context": "希尔排序\n技巧：\n子序列的构成不是简单地“逐段分割”\n将相隔某个增量dk的记录组成一个子序列\n让增量dk逐渐缩短（例如依次取5,3,1）\n直到dk=1为止。\n优点：\n小元素跳跃式前移\n最后一趟增量为1时，序列已基本有序\n平均性能优于直接插入排序",
        "source": "排序_PPT_第13页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第14页.png",
        "context": "例：关键字序列 T=(49，38，65，97，76，13，27，49*，55，04)\n\nr[i]\n初态：\n0 1 2 3 4 5 6 7 8 9 10\n49 38 65 97 76 13 27 49* 55 04\n\n第1趟 (dk=5):\n13 27 49* 55 04 49 38 65 97 76\n\n第2趟 (dk=3):\n13 04 49* 38 27 49 55 65 97 76\n\n第3趟 (dk=1):\n04 13 27 38 49* 49 55 65 76 97\n\n✓ dk 值较大，子序列中对象较少，速度较快；\n✓ dk 值逐渐变小，子序列中对象变多，但大多数对象已基本有序，所以排序速度仍然很快。",
        "source": "排序_PPT_第14页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第15页.png",
        "context": "8.3 交换排序\n基本思想：\n两两比较，如果发生逆序则交换，直到所有记录都排好序为止。\n冒泡排序 O(n²)\n快速排序 O( nlog₂ⁿ )",
        "source": "排序_PPT_第15页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第16页.png",
        "context": "冒泡排序\n基本思想：每趟不断将记录两两比较，并按“前小后大”规则交换\n21，25，49，25*，16，08\n21，25，25*，16，08，49\n21，25，16，08，25*，49\n21，16，08，25，25*，49\n16，08，21，25，25*，49\n08，16，21，25，25*，49",
        "source": "排序_PPT_第16页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第17页.png",
        "context": "快速排序\n基本思想：\n• 任取一个元素（如第一个）为中心\n• 所有比它小的元素一律前放，比它大的元素一律后放，形成左右两个子表；\n• 对各子表重新选择中心元素并依此规则调整，直到每个子表的元素只剩一个",
        "source": "排序_PPT_第17页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第18页.png",
        "context": "算法分析\n•可以证明，平均计算时间是O(nlog₂n)。\n•实验结果表明：就平均计算时间而言，快速排序是我们所讨论的所有内排序方法中最好的一个。\n•快速排序是递归的，需要有一个栈存放每层递归调用时参数（新的low和high）。\n•最大递归调用层次数与递归树的深度一致，因此，要求存储开销为 O(log₂n)。",
        "source": "排序_PPT_第18页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第1页.png",
        "context": "data structure\n第8章 排序",
        "source": "数据结构PPT_第1页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第20页.png",
        "context": "1. 熟练掌握直接插入排序、冒泡排序、快速排序、直接选择排序的算法实现及其性能分析\n2. 掌握希尔排序、归并排序、堆排序的方法及其性能分析\n3. 各种内部排序方法的比较（时间、空间、稳定性、选择原则）\n4. 堆的概念、判别方法、存储结构\n5. 掌握外部排序方法中败者树的建立及归并方法，掌握置换-选择排序的过程和最佳归并树的构造方法",
        "source": "排序_PPT_第20页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第21页.png",
        "context": "排序算法比较\n| 排序方法 | 平均时间 | 比较次数 | 移动次数 | 稳定性 | 附加存储 |\n|---------|----------|----------|----------|--------|----------|\n| 直接插入 | n^2      | n        | 0        | √      | 1        |\n| 折半插入 | n^2      | n log₂n  | 0        | √      | 1        |\n| 希尔排序 | n^1.3    |          | 0        | ×      | 1        |\n| 起泡排序 | n^2      | n        | 0        | √      | 1        |\n| 快速排序 | nlog₂n   | nlog₂n   | n log₂n  | ×      | log₂n    |\n| 简单选择 | n^2      | n²       | 0        | √      | 1        |\n| 堆排序   | nlog₂n   | n log₂n  | n log₂n  | ×      | 1        |\n| 归并排序 | nlog₂n   | n log₂n  | n log₂n  | √      | n        |\n| 基数排序 | d(n+rd)  |          |          | √      | n+rd     |\n（数据不是顺次后移时将导致方法不稳定）",
        "source": "排序_PPT_第21页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第22页.png",
        "context": "排序算法比较\n• 按平均时间排序方法分为四类\n  O(n^2)、O(nlogn)、O(n^{1+ε})、O(n)\n• 快速排序是基于比较的内部排序中平均性能最好的\n• 基数排序时间复杂度最低，但对关键字结构有要求\n知道各级关键字的主次关系\n知道各级关键字的取值范围",
        "source": "排序_PPT_第22页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第23页.png",
        "context": "排序算法比较\n✓ 为避免顺序存储时大量移动记录的时间开销，可考虑用链表作为存储结构\n直接插入排序、归并排序、基数排序\n✓ 不宜采用链表作为存储结构的\n折半插入排序、希尔排序、快速排序、堆排序",
        "source": "排序_PPT_第23页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第24页.png",
        "context": "排序算法选择规则\nn较大时\n（1）分布随机，稳定性不做要求，则采用快速排序\n（2）内存允许，要求排序稳定时，则采用归并排序\n（3）可能会出现正序或逆序，稳定性不做要求，则采用堆排序或归并排序\nn较小时\n（1）基本有序，则采用直接插入排序\n（2）分布随机，则采用简单选择排序，若排序码不接近逆序，也可以采用直接插入排序",
        "source": "排序_PPT_第24页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第2页.png",
        "context": "数据结构：\n逻辑结构 {\n线性结构（线性表、栈、队、串、数组）\n非线性结构 {\n树结构\n图结构\n}\n物理（存储）结构 {\n顺序结构\n链式结构\n}\n数据运算 {\n插入运算\n删除运算\n修改运算\n查找运算\n排序运算\n}",
        "source": "排序_PPT_第2页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第3页.png",
        "context": "教学内容\n8.1 概述\n8.2 插入排序\n8.3 交换排序\n8.4 选择排序\n8.5 归并排序\n8.6 基数排序",
        "source": "排序_PPT_第3页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第4页.png",
        "context": "教学目标\n1. 掌握排序的基本概念和各种排序方法的特点，并能加以灵活应用\n2. 熟练掌握直接插入排序、折半插入排序、起泡排序、直接选择排序、快速排序的排序算法及其性能分析\n3. 掌握希尔排序、归并排序、堆排序、基数排序的方法及其性能分析",
        "source": "排序_PPT_第4页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第5页.png",
        "context": "8.1 概述\n\n1. 什么是排序？\n将一组杂乱无章的数据按一定规律顺次排列起来。\n存放在数据表中\n按关键字排序\n\n2. 排序的目的是什么？\n——便于查找！",
        "source": "排序_PPT_第5页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第6页.png",
        "context": "3. 什么叫内部排序？什么叫外部排序？\n- 若待排序记录都在内存中，称为内部排序；\n- 若待排序记录一部分在内存，一部分在外存，则称为外部排序。\n注：外部排序时，要将数据分批调入内存来排序，中间结果还要及时放入外存，显然外部排序要复杂得多。",
        "source": "排序_PPT_第6页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第7页.png",
        "context": "4. 排序算法的好坏如何衡量？\n• 时间效率——排序速度（比较次数与移动次数）\n• 空间效率——占内存辅助空间的大小\n• 稳定性——A和B的关键字相等，排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。",
        "source": "排序_PPT_第7页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第8页.png",
        "context": "排序算法分类\n规则不同\n插入排序\n交换排序\n选择排序\n归并排序\n时间复杂度不同\n简单排序O(n²)\n先进排序O( nlog₂ⁿ )",
        "source": "排序_PPT_第8页",
        "date": "2025-01-01 13:44:38"
    },
    {
        "filename": "排序_PPT_第9页.png",
        "context": "8.2 插入排序\n基本思想：\n每步将一个待排序的对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，直到对象全部插入为止。\n即边插入边排序，保证子序列中随时都是排好序的",
        "source": "排序_PPT_第9页",
        "date": "2025-01-01 13:44:38"
    }
]